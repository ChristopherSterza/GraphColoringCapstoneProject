\documentclass[12pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{float}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{hyperref}
\usepackage[ruled,vlined]{algorithm2e}


\usepackage{courier} %% Sets font for listing as Courier.
\usepackage{listings, xcolor}
\lstset{
tabsize = 4, %% set tab space width
showstringspaces = false, %% prevent space marking in strings, string is defined as the text that is generally printed directly to the console
numbers = left, %% display line numbers on the left
commentstyle = \color{green}, %% set comment color
keywordstyle = \color{blue}, %% set keyword color
stringstyle = \color{red}, %% set string color
rulecolor = \color{black}, %% set frame color to avoid being affected by text color
basicstyle = \small \ttfamily , %% set listing font and size
breaklines = true, %% enable line breaking
numberstyle = \tiny,
}




\title{Graph Coloring and the Welsh-Powell Algorithm}
\author{Christopher Sterza}
\date{June 13, 2020}


\begin{document}
\begin{titlepage}
\maketitle
\end{titlepage}


\begin{abstract}
This paper is meant to explore the concept of graph coloring and specifically the Welsh Powell algorithm. The algorithm will be analyzed, implemented, and used to analyze special families of graphs and solve typical graph coloring problems. 
\end{abstract}
\section*{Definitions and Terminology}
As we learned in class, graphs are mathematical structures defined by a set of vertices $V$ and a set of edges $E$. Graphs are very flexible and are used to model many things such as friend networks, road networks, scheduling, game states, and much more.


For the purposes of this paper, we'll define a graph $G=(V,E)$ where $V=\{v_1,...,v_n\}, E=\{(a,b) \in V^2\mid a\text{ attatched to } b\}$. We also call vertices $v_1,v_2$ \textit{adjacent} if $(v_1,v_2)\in E$. All graphs in this paper will be \textit{undirected} which means that $\forall (a,b)\in E,(b,a)\in E$, however we will omit similar edges for simplicity. We also note the \textit{degree} of a vertex $v$, denoted $deg(v)$, is the number of edges connected to the vertex. Lastly, a \textit{clique} of a graph $G$, is a subgraph $G'=(V',E')$ such that $V'\subseteq V,E'\subseteq E$ and $(v_1,v_2)\in E' \forall v_1,v_2 \in V'$. The size of the clique is often denoted $\omega(G')$ where $\omega(G')= \mid V' \mid$.


Graph coloring is a special labeling of a graph, in which certain properties of a graph are assigned a color. There are a few ways to color a graph, among which are vertex coloring, edge coloring, and face coloring. In this paper we will focus on vertex coloring and its applications.


Vertex coloring is one of the most common graph problems. The problem is, given $n$ colors from a set $C=\{c_1,...,c_n\}$, find a way to color the vertices of a graph such that no two adjacent vertices have the same color. Should a coloring exist and the colors be applied appropriately, we call the graph \textit{properly colored}. The \textit{chromatic number} of a graph is the minimum number of colors required to properly color a graph and is often denoted as $\chi (G)$. We know that $\chi(G)\geq \omega(G)$\cite{nistmath} and so the lower bound of $\chi(G)$ must be $\omega(G)$. Let's apply this terminology to Figure 1 below.


Figure 1(a) is a graph $G=(V,E), V=\{0,1,2,3\}, E=\{(0,1),(0,2),\\(1,2),(1,3)\}$ where $deg(0)=2,deg(1)=3,deg(2)=2,deg(3)=1$. In Figure 1(b), $G$ is properly colored and $\chi (G)=3$. In Figure 1(c), $G$ is not properly colored. In all three, the largest clique is $G'=(V',E'),V'=\{0,1,2\},E'=\{(0,1),(0,2),(1,2)\}$, and $\omega(G')=3$.


\begin{figure}%
    \centering
    \subfloat[]{{\includegraphics[scale=.4]{figure1a.png} }}%
    \qquad
    \subfloat[]{{\includegraphics[scale=.4]{figure1b.png} }}%
    \qquad
    \subfloat[]{{\includegraphics[scale=.4]{figure1c.png} }}%
    \caption{}
\end{figure}
Vertex coloring has a variety of uses in scheduling, identifying bipartite graphs, solving sudoku, and coloring maps. The typical first step in finding a coloring is to first create a graph that models the situation; vertices representing certain objects, and edges connecting objects which conflict with one another. In the case of coloring a map, the vertices would represent the countries/regions and the edges would represent countries that border one another. This way, a proper coloring would assign a color to each country such that its bordering countries would be a different color, eliminating confusion when looking at a map. 
\section*{Welsh-Powell Algorithm}
Because vertex coloring is such a common problem, many people have attempted to find algorithms to color a graph, hopefully using no more than $\chi (G)$ colors. Unfortunately, finding $\chi(G)$ has been proven to be an NP-Complete problem back in 1972, and so no fast algorithm exists. Despite this, algorithms exist to find proper colorings of a graph, although they cannot guarantee it is done in $\chi(G)$ colors.


One of the most popular such algorithms is the Welsh-Powell Algorithm, which attempts to find a coloring with the least number of colors by first coloring the vertices of the highest degree. The assumption is, by taking care of the higher degree vertices first, we reduce the chances of collisions later which would require an additional color. This algorithm is an example of a greedy algorithm\cite{GeeksforGeeks} which selects the next move based on what is currently the best option. Greedy algorithms do not backtrack. The steps for the Welsh-Powell algorithm are outlined below.


\begin{algorithm}[H]
\SetAlgoLined
\textbf{Data:} 


$V=\{v_1,...,v_n\}$\\
$E=\{(a,b)\in V^2 \mid a\text{ adjacent to } b\}$\\
$C=\{c_1,...c_n\}$\\
\textbf{Procedure:}


Step 1: Find $deg(v)\forall v\in V$.\\
Step 2: Sort $V$ in order of descending degrees.\\
Step 3: Assign $c_i$ to first element $v_i$ in sorted $V$.\\
Step 4: Iterate through $V$ and if $(v_i,v_j)\notin E$, assign $c_i$ to $v_j$.\\
Step 5: Increment to the next color and repeat steps 3-4 until all vertices are colored.
\caption{Welsh-Powell Algorithm}
\end{algorithm}


To visualize this algorithm, let's perform the steps on the graph in Fig 2.


\begin{figure}[h!]%
\begin{center}
	\subfloat(a){{\includegraphics[scale=.2]{figure2a.png}}}%
	\qquad
	\subfloat(b){{\includegraphics[scale=.2]{figure2b.png}}}%
	\subfloat(c){{\includegraphics[scale=.2]{figure2c.png}}}%
	\qquad
	\subfloat(d){{\includegraphics[scale=.2]{figure2d.png}}}%
\end{center}
\end{figure}
\begin{figure}[h!]\ContinuedFloat%
\begin{center}
	\subfloat(e){{\includegraphics[scale=.2]{figure2e.png}}}%
	\qquad
	\subfloat(f){{\includegraphics[scale=.2]{figure2f.png}}}%
	\subfloat(g){{\includegraphics[scale=.2]{figure2g.png}}}%
	\caption*{Figure 2}
\end{center}
\end{figure}


As we can see from the graph, $V=\{0,1,2,3,4,5,6,7,8,9,10\},\text{ and }\\
 E=\{(0,1),(0,7),(1,3),(2,3),(3,8),(3,10),(4,10),(4,5),(5,6),(6,7),\\(6,10),(7,8),(7,9),(7,10),(8,9),(9,10)\}$. The first step is to find the degree of each vertex. The degrees are:
 \begin{align*}
 &deg(0)=2\\
 &deg(1)=2\\
 &deg(2)=1\\
 &deg(3)=4\\
 &deg(4)=2\\
 &deg(5)=2\\
 &deg(6)=3\\
 &deg(7)=5\\
 &deg(8)=3\\
 &deg(9)=3\\
 &deg(10)=5
 \end{align*}
 The second step is to reorder $V$ by descending degrees. \\$V=\{7,10,3,6,8,9,0,1,4,5,2\}$.
 The third step is to assign $c_1 =$ red to $v_7 = 7$ as seen in Figure 2(b). The fourth step is to iterate through $V$ and assign $c_1$ to the vertices non-adjacent to $v_7$. Therefore we assign $c_1$ to $v_3$ and $v_4$ as seen in Figure 2(c). For the fifth step, we increment to the next color $c_2=$ blue and repeat steps 3-4. This is shown in Figures 2(d) and 2(e). Then we increment the color to $c_3 =$ green and repeat. The results are shown in Figures 2(f) and 2(g). After this, the graph is fully and properly colored and we only used $\chi(G)=3$ colors. We know that this is the chromatic number since the size of the largest clique in $G$ is $\omega(G')=3$ where $G'=(V',E'),V'=\{7,8,9\},E'=\{(7,8),(7,9),(8,9)\}$.
 
\section*{My Code Implementation of the Welsh-Powell Algorithm}
Now that we have seen the theory behind how the Welsh-Powell algorithm works, let's take a look at it in action. My programming language of choice is Java so the code in this section will be written in it.


To begin, I decided to create a graph object class since working with graph objects is considerably easier when toying with multiple different graphs. To implement this graph object, I opted to use a Boolean adjacency matrix $V\times V$ where the value of the matrix at $(v_1,v_2)$ was true if an edge $(v_1,v_2)\in E$ and false otherwise. A reduced version of my source code is shown below. It includes the barebones skeleton members and methods of the graph object. Not shown are other helper methods. My full source code can be found at \url{https://github.com/ChristopherSterza/GraphColoringCapstoneProject/blob/master/Main.java}.


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
// Graph object which is represented by an adjacency matrix.
//
// int vertexCount: The number of vertices in the graph.
// boolean[][] adjMatrix: The 2D array matrix that represents the graph. the indices represent the vertices and the
// value of a cell in the matrix represents an edge if true, or no edge if false.
// Integer[][] degreeArray: The 2D array holding the vertices and their respective degrees. It is two dimensional in
// order to keep track of the vertex indices when sorted by descending degree.
// Integer[] coloredArray: An array that holds the color of the indexed vertex.
// boolean[] colored: An array that keeps track of which vertices have been colored.
class Graph{
    private int vertexCount =0;
    private boolean[][] adjMatrix;
    private Integer[][] degreeArray;
    private Integer[] coloredArray;
    private boolean[] colored;


    // Graph constructor.
    public Graph(int vertexCount) {
        this.vertexCount = vertexCount;
        adjMatrix = new boolean[vertexCount][vertexCount];
        degreeArray = new Integer[vertexCount][2];
        coloredArray = new Integer[vertexCount];


    }


    // Returns the number of vertices in the graph.
    public int getVertexCount() {
        return vertexCount;
    }


    public boolean[][] getAdjMatrix() {
        return adjMatrix;
    }


    // Adds an edge to the graph between the two specified vertices.
    public void addEdge(int v1,int v2){
        adjMatrix[v1][v2] = true;
        adjMatrix[v2][v1] = true;
    }


    // Removes the edge to the graph between the two specified vertices.
    public void removeEdge(int v1, int v2){
        adjMatrix[v1][v2] = false;
        adjMatrix[v2][v1] = false;
    }


    // Returns a string which represents the adjacency matrix for the graph.
    public String toString() {
        StringBuilder s = new StringBuilder();
        for (int i = 0; i < vertexCount; i++) {
            s.append(i + ": ");
            for (boolean j : adjMatrix[i]) {
                s.append((j ? 1 : 0) + " ");
            }
            s.append("\n");
        }
        return s.toString();
    }
}
\end{lstlisting}


Using these graph objects, we can easily and quickly create multiple graph objects and use them independently of one another. With these graph objects created, I decided to implement the Welsh-Powell algorithm as a public method from within the graph class. The code is as follows.


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
// Fills an array where the indices are the vertices and the value is the color used to color that vertex.
    // Does so by creating a boolean array that keeps track if a particular vertex is colored. Then creates the 2D
    // array that keeps track of the vertices and their degree. Sorts the array in descending order by degree. Then
    // starting with color 0, we iterate throughout the list of vertices. We set the current vertex to the vertex
    // we're coloring in the array. If the current vertex is not colored, set the current vertex in the colored array
    // to the current color. Then we mark it colored in the colored array. Next, we iterate throughout the other
    // vertices and if the other vertices aren't adjacent to the current vertex and the new vertex in question isn't
    // colored, we compare this new vertex to its adjacent vertices. If its adjacent to a vertex with the current
    // color, we must iterate it to the next color and check that. Once we find a color that isn't adjacent to this
    // new vertex, we color it and mark it as colored in the colored array. Then we go back to the original current
    // color and check the next non-adjacent vertex. Once we've colored all possible vertices this color, move onto
    // the next color and repeat.
    public void welshPowell(){
        boolean[] colored = new boolean[vertexCount];
        degreeArray = allDegrees();
        degreeArray = sort2DArray(degreeArray);
        int currColor = 0;
        for (int i = 0; i < degreeArray.length; i++) {
            Integer currVertex = degreeArray[i][0];
            if (!colored[currVertex]){
                coloredArray[currVertex] = currColor;
                colored[currVertex] = true;
                for (int j = 0; j < vertexCount; j++) {
                    int tempVertex = degreeArray[j][0];
                    if (!adjMatrix[currVertex][tempVertex] && !colored[tempVertex]){
                        if (!hasAdjacentColor(tempVertex,currColor)){
                            coloredArray[tempVertex] = currColor;
                            colored[tempVertex] = true;
                        }
                    }
                }
                currColor++;
            }
        }
    }
\end{lstlisting}


The way this code works is it begins by creating a boolean array that keeps track of which vertices have been colored. Next it takes the degreeArray graph member which holds the vertices and their respective degrees and uses the helper method allDegrees() to fill it with all the vertices and their degrees as per step 1 of the algorithm. Next, we pass that array into the sort2DArray() helper method to sort the vertices in degreeArray by descending degrees as per step 2 of the algorithm. Next we start with the first color, 0, which is stored in the variable currColor. We iterate through the vertices starting with the first vertex in the ordered set, placing it an a variable called currVertex. We then color the first vertex that is not colored as per step 3 of the algorithm. After, we take note of the color it was assigned and mark it as colored. Once it is colored, we iterate through the other vertices in the graph and if a particular vertex is not adjacent to the current vertex and it is not already colored, check to see if it is adjacent to the current color and if not, assign it the current color and mark the vertex as colored as per step 4 of the algorithm. Lastly, increment the current color to the next color and repeat steps 3-4 of the algorithm as per step 5 of the algorithm. Now, let's test our algorithm by running the following driver code.


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class Main {
    public static void main(String args[]){
    		//Create graph with 11 vertices
        Graph g = new Graph(11);
        //add edges
        g.addEdge(0,1);
        g.addEdge(0,7);
        g.addEdge(1,3);
        g.addEdge(2,3);
        g.addEdge(3,8);
        g.addEdge(3,10);
        g.addEdge(4,5);
        g.addEdge(4,10);
        g.addEdge(5,6);
        g.addEdge(6,7);
        g.addEdge(6,10);
        g.addEdge(7,8);
        g.addEdge(7,9);
        g.addEdge(7,10);
        g.addEdge(8,9);
        g.addEdge(9,10);
        // Run the Welsh-Powell algorithm and print the results
        g.welshPowell();
        g.printColoring();
    }
}
\end{lstlisting}


The output for this code is as follows.
\begin{center}
\includegraphics[scale=1]{output1.png}
\end{center}


As we can see, 3 colors were used which was also $\chi(G)$ and if we check the coloring with Figure 2(g) where color 0 is red, color 1 is blue, and color 2 is green, we find the coloring matches.


\section*{Comparing Welsh-Powell Colorings with Chromatic Number Colorings for Common Graph Families}


Now that we see how the Welsh-Powell algorithm works with code, we can use it to color common families of graphs and see if it is able to constrain the number of colors to just $\chi(G)$.


A \textbf{complete graph on \textit{n} vertices} is typically denoted by $K_n$ and is a simple graph that contains exactly one edge between each pair of distinct vertices. For the family of complete graphs, $\chi(K_n)=n$ since every complete graph is also its own largest clique by definition. The graphs $K_n$ for $n=1,2,3,4,5$ are shown in Figure 3.


\begin{figure}[h]%
\begin{center}
	\subfloat{{\includegraphics[scale=.3]{k1.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.3]{k2.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.3]{k3.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.3]{k4.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.3]{k5.png}}}%
	\caption*{Figure 3}
\end{center}
\end{figure}


Using the folowing driver code to check our algorithm


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class Main {
    public static void main(String args[]){
        //Create complete graphs
		GraphBuilder gb = new GraphBuilder();
        Graph k1 = gb.createCompleteGraph(1);
        Graph k2 = gb.createCompleteGraph(2);
        Graph k3 = gb.createCompleteGraph(3);
        Graph k4 = gb.createCompleteGraph(4);
        Graph k5 = gb.createCompleteGraph(5);
        //Run the algorithm
        k1.welshPowell();
        k2.welshPowell();
        k3.welshPowell();
        k4.welshPowell();
        k5.welshPowell();
        //Print results
        k1.printColoring();
        System.out.print("\n");
        k2.printColoring();
        System.out.print("\n");
        k3.printColoring();
        System.out.print("\n");
        k4.printColoring();
        System.out.print("\n");
        k5.printColoring();
	}
}
\end{lstlisting}


Results in the following output from the console


\begin{center}
\includegraphics[scale=.75]{knCodeOutput.png}
\end{center}


As we can see, the algorithm is able to accurately color the family of $K_n$ graphs using $\chi(K_n)$ colors.


A \textbf{cycle on \textit{n} vertices} is typically denoted by $C_n,n\geq3$ consists of $n$ vertices $v_1,v_2,...,v_n$ and edges $(v_1,v_2),(v_2,v_3),...,(v_n-1,v_n),(v_n,1)$. For the family of cycle graphs, $\chi(C_n)=2$ if $n$ is even and $\chi(C_n)=3$ if $n$ is odd. This is because with an even number of vertices, one can just alternate colors, however with an odd number of vertices, the last vertex is attached to both colors and so a new color is required. The cycles $C_3,C_4,C_5$ are displayed in Figure 4.


\begin{figure}[h!]%
\begin{center}
	\subfloat{{\includegraphics[scale=.4]{c3.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.4]{c4.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.4]{c5.png}}}%
	\caption*{Figure 4}
\end{center}
\end{figure}


Using the following driver code to check our algorithm


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class Main {
    public static void main(String args[]){
        //Create the cycle graphs
        GraphBuilder gb = new GraphBuilder();
        Graph c3 = gb.createCycleGraph(3);
        Graph c4 = gb.createCycleGraph(4);
        Graph c5 = gb.createCycleGraph(5);
        //Run the algorithm
        c3.welshPowell();
        c4.welshPowell();
        c5.welshPowell();
        //Print the results
        c3.printColoring();
        System.out.print("\n");
        c4.printColoring();
        System.out.print("\n");
        c5.printColoring();
    }
}
\end{lstlisting}


Results in the following output from the console


\begin{center}
\includegraphics[scale=.75]{cnCodeOutput.png}
\end{center}


As we can see, the algorithm is able to accurately color the family of $C_n$ graphs using $\chi(C_n)$ colors.


We obtain a \textbf{wheel} $W_n$ when we add an additional vertex to a cycle $C_n$ and connect this vertex to each of the $n$ vertices in $C_n$. For the family of wheel graphs, $\chi(W_n)=\chi(C_n)+1$. This is because the chromatic number of the cycle component of the wheel remains the same, but now there's an extra vertex connected to all other vertices so it requires its own extra color. Therefore, $\chi(W_n)=4$ if $n$ is odd and $\chi(W_n)=3$ if $n$ is even. The wheels $W_3,W_4,W_5$ are displayed in Figure 5.


\begin{figure}[h!]%
\begin{center}
	\subfloat{{\includegraphics[scale=.4]{w3.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.4]{w4.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.4]{w5.png}}}%
	\caption*{Figure 5}
\end{center}
\end{figure}


Using the following driver code to check our algorithm


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class Main {
    public static void main(String args[]){
        //Create the wheel graphs
        GraphBuilder gb = new GraphBuilder();
        Graph w3 = gb.createWheelGraph(3);
        Graph w4 = gb.createWheelGraph(4);
        Graph w5 = gb.createWheelGraph(5);
        //Run the algorithm
        w3.welshPowell();
        w4.welshPowell();
        w5.welshPowell();
        //Print the results
        w3.printColoring();
        System.out.print("\n");
        w4.printColoring();
        System.out.print("\n");
        w5.printColoring();
    }
}
\end{lstlisting}


Results in the following output from the console


\begin{center}
\includegraphics[scale=.75]{wnCodeOutput.png}
\end{center}


As we can see, the algorithm is able to accurately color the family of $W_n$ graphs using $\chi(W_n)$ colors.


An \textbf{\textit{n-}dimensional hypercube}, or \textbf{\textit{n-}cube}, denoted by $Q_n$, is a graph that has vertices representing the $2^n$ bitstrings of length $n$. Two vertices are adjacent if and only if the bitstrings they represent differ in exactly one bit position. For the family of $n-$cube graphs, $\chi(Q_n)=2$. This is because every vertex is only adjacent to another if they differ by one bit position. This means that for a vertex $v_i$,an adjacent vertex $v_j$ is also adjacent to a different vertex $v_k$ but $v_k$ since the path from $v_i$ to $v_k$ is 2 edges long, $v_i$ and $v_k$ differ by two bit positions and so aren't adjacent to each other. Therefore one only needs to alternate colors along all paths and $\chi(Q_n)=2$. The only exception to this is $Q_0$ since there is only 1 vertex that needs to be colored, so $\chi(Q_0)=1$. The hypercubes $Q_0,Q_1,Q_2,Q_3$ are displayed in Figure 6.


\begin{figure}[h!]%
\begin{center}
	\subfloat{{\includegraphics[scale=.4]{q0.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.4]{q1.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.4]{q2.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.4]{q3.png}}}%
	\caption*{Figure 6}
\end{center}
\end{figure}


Using the following driver code to check our algorithm


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class Main {
    public static void main(String args[]){
        //Create the cube graphs
        GraphBuilder gb = new GraphBuilder();
        Graph q0 = gb.createCubeGraph(0);
        Graph q1 = gb.createCubeGraph(1);
        Graph q2 = gb.createCubeGraph(2);
        Graph q3 = gb.createCubeGraph(3);
        //Run the algorithm
        q0.welshPowell();
        q1.welshPowell();
        q2.welshPowell();
        q3.welshPowell();
        //Print the results
        q0.printColoring();
        System.out.print("\n");
        q1.printColoring();
        System.out.print("\n");
        q2.printColoring();
        System.out.print("\n");
        q3.printColoring();
    }
}
\end{lstlisting}


Results in the following output from the console


\begin{center}
\includegraphics[scale=.75]{qnCodeOutput.png}
\end{center}


As we can see, the algorithm is able to accurately color the family of $Q_n$ graphs using $\chi(Q_n)$ colors.


Lastly, a graph $G=(V,E)$ is said to be a \textbf{bipartite graph} if its vertex set $V$ can be partitioned into two disjoint sets $V_1$ and $V_2$ such that every edge in $E$ connects a vertex 	in $V_1$ and a vertex in $V_2$ (so that no edge in $E$ connects either two vertices in $V_1$ or two vertices in $V_2$). A bipartite graph is said to be a \textbf{complete bipartite graph}, denoted $K_{m,n}$ when all $m$ vertices in set $V_1$ have an edge to all other $n$ vertices in set $V_2$. All bipartite graphs have a chromatic number of 2. This is because all the elements in their respective set are only connected to one other set of elements. And since the vertices in both sets aren't connected to others in their own sets, vertices in a set can all be colored the same color. Therefore since there are two sets of vertices in a bipartite graph, there are only two necessary colors. The complete bipartite graphs $K_{2,3},K_{2,4},K_{3,5}$ are displayed in Figure 7.


\begin{figure}[h!]%
\begin{center}
	\subfloat{{\includegraphics[scale=.4]{k23.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.4]{k24.png}}}%
	\qquad
	\subfloat{{\includegraphics[scale=.4]{k35.png}}}%
	\caption*{Figure 7}
\end{center}
\end{figure}


Using the following driver code to check our algorithm


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class Main {
    public static void main(String args[]){
        //Create the complete bipartite graphs
        GraphBuilder gb = new GraphBuilder();
        Graph k23 = gb.createCompleteBipartiteGraph(2,3);
        Graph k24 = gb.createCompleteBipartiteGraph(2,4);
        Graph k35 = gb.createCompleteBipartiteGraph(3,5);
        //Run the algorithm
        k23.welshPowell();
        k24.welshPowell();
        k35.welshPowell();
        //Print the results
        k23.printColoring();
        System.out.print("\n");
        k24.printColoring();
        System.out.print("\n");
        k35.printColoring();
    }
}
\end{lstlisting}


Results in the following output from the console


\begin{center}
\includegraphics[scale=.75]{kmnCodeOutput.png}
\end{center}


As we can see, the algorithm is able to accurately color the family of $K_{m,n}$ graphs using $\chi(K_{m,n})$ colors.


\section*{Problem Solving with the Welsh-Powell Algorithm}


So far, despite not being able to guarantee a coloring with $\chi(G)$ colors, the Welsh-Powell algorithm has been doing an excellent job at providing us with the actual chromatic numbers for the special graphs we've looked at. Next, we'll try applying the algorithm to some problems which can be modeled by a graph, and solved by finding a proper coloring.


Take for example a wedding planner who needs to seat an arrangement of people at the reception. In attendance will be Alice, Bob, Chris, Dianne, Eli, Fara, Grace, Harvey, Ira, Jude, and Ken. These guests however are very petty and refuse to sit at the same table as certain individuals with whom they've had issues with in the past. Alice won't sit with Ken or Dianne, Fara won't sit with Harvey, Bob won't sit with Dianne, Grace or Harvey, Chris won't sit with Grace or Jude, and Eli won't sit with Dianne. How many tables will the wedding planner need to acommodate everyone and who will sit at which table? 


We can start tackling this problem by modeling the situation with a graph, where the vertices are the guests and edges connect guests that refuse to sit with one another. The resulting graph looks like Figure 8(a). For the purposes of my code, let's assign each person in alphabetical order to an ascending integer starting with 0. This means that
\begin{align*}
&v_0 \text{ is Alice}\\
&v_1 \text{ is Bob}\\
&v_2 \text{ is Chris}\\
&v_3 \text{ is Dianne}\\
&v_4 \text{ is Eli}\\
&v_5 \text{ is Fara}\\
&v_6 \text{ is Grace}\\
&v_7 \text{ is Harvey}\\
&v_8 \text{ is Ira}\\
&v_9 \text{ is Jude}\\
&v_{10} \text{ is Ken}
\end{align*}


Then we use this information in conjunction with our code to give us the following driver code


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class Main {
    public static void main(String args[]){
        //Create a custom graph with 11 vertices for each person in attendance
        Graph solution = new Graph(11);
        solution.addEdge(0,3); //Alice, Dianne
        solution.addEdge(0,10);//Alice, Ken
        solution.addEdge(1,3);//Bob, Dianne
        solution.addEdge(1,6);//Bob, Grace
        solution.addEdge(1,7);//Bob, Harvey
        solution.addEdge(2,6);//Chris, Grace
        solution.addEdge(2,9);//Chris, Jude
        solution.addEdge(3,4);//Dianne, Eli
        solution.addEdge(5,7);// Fara, Harvey
        //Run the algorithm
        solution.welshPowell();
        //Print out the results
        solution.printColoring();
    }
}
\end{lstlisting}


Which results in the following output after the graph is processed by the algorithm


\begin{center}
\includegraphics[scale=1]{weddingOutput.png}
\end{center}


Very quickly and easily, the algorithm is able to return a coloring of just 2 colors which just so happens to also be the chromatic number of the graph since the largest clique in the graph is only two vertices. If we apply the coloring the algorithm produced to the graph, we get the properly colored graph in Figure 8(b). Now the wedding planner knows that they only need to rent two tables and they can sit Alice, Bob, Chris, Eli, Fara, and Ira at one table and Dianne, Grace, Harvey, Jude, and Ken at the other table. The reception is saved!


\begin{figure}[h!]%
\begin{center}
	\subfloat[]{{\includegraphics[scale=.4]{wedding1.png}}}%
	\qquad
\subfloat[]{{\includegraphics[scale=.4]{wedding2.png}}}%
	\caption*{Figure 8}
\end{center}
\end{figure}


Another application that demonstrates the versatility of graphs and the Welsh-Powell algorithm is the problem of scheduling. Often times, people need to schedule certain things so that they do not conflict with one another on a timeline. A great and apt example would be finals week at Santa Monica College! For simplicity sake, let's focus on the math department at SMC. Many STEM students, especially as they approach their higher division math classes, tend to take a few math classes in the same semester. This can cause problems when trying to schedule finals since if two classes have their finals scheduled for the same time block and a student happens to be in both classes, the student can't possibly take both finals at the same time. How can the testing coordinator at SMC schedule the classes so that no students have conflicting finals? This is another problem that can be solved via graph coloring. Say we need to schedule finals for the classes Math 2, Math 7, Math 8, Math 10, Math 11, Math 13, Math 15, Math 21 and Math 54. We can model this as a graph where each class is a vertex, and vertices are connected by an edge if a student is in both classes concurrently. Then we can apply the Welsh-Powell algorithm to this graph to find the required number of time blocks. Many math classes at SMC are sequential. Therefore there are going to be some classes that can't be taken in conjunction with other. Namely Math 2 $\rightarrow$ Math 7 $\rightarrow$ Math 8 $\rightarrow$ Math 10,11,13,15. Also, common pairings of classes taken together in the upper division math courses are Math 11,15 and Math 10,13. Some students also take Math 11,13 together Math 21,54 together, and Math 2,54 together. With this in mind, the graph that would model the situation closest  is shown in Figure 9(a). For the sake of my code, let's also reassign the vertices 0,...,8 to the math courses in ascending order. This means that
\begin{align*}
&v_0 \text{ is Math 2}\\
&v_1 \text{ is Math 7}\\
&v_2 \text{ is Math 8}\\
&v_3 \text{ is Math 10}\\
&v_4 \text{ is Math 11}\\
&v_5 \text{ is Math 13}\\
&v_6 \text{ is Math 15}\\
&v_7 \text{ is Math 21}\\
&v_8 \text{ is Math 54}
\end{align*}
Then we use this information in conjunction with our code to give us the following driver code


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class Main {
    public static void main(String args[]){
        //Create a custom graph with 9 vertices for each class that needs scheduling
        Graph scheduling = new Graph(9);
        scheduling.addEdge(0,8);//Math 2, Math 54
        scheduling.addEdge(3,5);//Math 10, Math 13
        scheduling.addEdge(4,5);//Math 11, Math 13
        scheduling.addEdge(4,6);//Math 11, Math 15
        scheduling.addEdge(7,8);//Math 21, Math 54
        //Run the algorithm
        scheduling.welshPowell();
        //Print out the results
        scheduling.printColoring();
    }
}
\end{lstlisting}


Which results in the following output after the graph is processed by the algorithm


\begin{center}
\includegraphics[scale=1]{mathSchedulingOutput.png}
\end{center}


Once again, the algorithm is able to find us a proper coloring for our graph. If we apply this coloring to our graph, we get Figure 9(b). In this case, the testing coordinator knows that they only need two time blocks to schedule all the classes so that none of the finals overlap. In one time block they can schedule finals for Math 7,8,10,11, and 54 and in the other time block they can schedule finals for Math 2,13,15, and 21.


\begin{figure}[h!]%
\begin{center}
	\subfloat[]{{\includegraphics[scale=.4]{mathScheduling1.png}}}%
	\qquad
\subfloat[]{{\includegraphics[scale=.4]{mathScheduling2.png}}}%
	\caption*{Figure 9}
\end{center}
\end{figure}


The last application of the Welsh-Powell algorithm I wanted to explore is solving sudoku puzzles. For those unaware, sudoku is a puzzle game consisting of a 9x9 grid of squares. These squares must be filled with a number from 1 to 9 such that no numbers are repeated in the same row, column, or respective 3x3 square. A sudoku puzzle is essentially just another graph coloring problem. A sudoku grid can be thought of as a graph where every cell is a vertex and vertices are connected by edges if they are in the same row, column or 3x3 square. This results in a large graph that is heavily connected. Sudoku graphs have 81 nodes and every node has 20 edges. Since this graph model is undirected, there's half as many edges since each vertex shares the same edge. That means there's a total of $\frac{81\cdot 20}{2}= 810$ unique edges. With this graph, the colors represent numbers, so we need to find a proper coloring in order to find a solution.




\begin{figure}[h!]%
\begin{center}
	\subfloat[A simplified sudoku grid graph]{{\includegraphics[scale=.4]{sudokuGraph.png}}}%
\end{center}
\end{figure}


To tackle this problem, I found it best to create a SudokuGrid class that automatically initializes a sudoku grid graph since they're consistently sized and would be a pain to set up a custom grid by hand. The source code for the SudokuGrid class I wrote is as follows.


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
// This class is used to represent a sudoku grid and provide some simple methods of interest.
//
// Graph grid: a Graph object used to represent the sudoku grid.
// Integer[] values: And array that holds the values currently stored in the sudoku grid.
class SudokuGrid{
    private Graph grid;
    private Integer[] values;


    public SudokuGrid(Integer[] knownValues){
        values = knownValues;
        grid = new Graph(81);
        ArrayList<Integer> connectedSet = new ArrayList<>() ;
        // Connect rows.
        for (int i = 0; i < 81; i += 9) {
            for (int j = i; j < (i+9); j++) {
                connectedSet.add(j);
            }
            connectSet(connectedSet);
            connectedSet.clear();
        }
        // Connect columns.
        for (int i = 0; i < 9; i++) {
            for (int j = i; j < 81; j += 9) {
                connectedSet.add(j);
            }
            connectSet(connectedSet);
            connectedSet.clear();
        }
        //Connect 3x3 squares.
        for (int i = 0; i < 81; i += 27) {
            for (int j = i; j < (i+9); j += 3) {
                for (int k = j; k < (j+27); k += 9) {
                    for (int l = k; l < (k+3); l++) {
                        connectedSet.add(l);
                    }
                }
                connectSet(connectedSet);
                connectedSet.clear();
            }
        }
    }


    // Uses the Welsh-Powell algorithm for partially solved graphs.
    public void solve(){
        values = grid.partiallySolvedWelshPowell(values);
    };


    // Prints the completed grid to the console.
    public void printSolution(){
        for (int i = 0; i < values.length; i++) {
            if (i%9==0) System.out.print("\n");
            System.out.print(values[i] + ",");
        }
    }


    // Helper method used to connect vertices in the sudoku grid graph.
    private void connectSet(ArrayList<Integer> connectedSet){
        for (int i = 0; i < connectedSet.size(); i++) {
            for (int j = 0; j < connectedSet.size(); j++) {
                grid.addEdge(connectedSet.get(i),connectedSet.get(j));
            }
        }
    }
}
\end{lstlisting}


This class is very short and straightforward. The constructor takes an Integer array of initial values and constructs the graph with its initial colored vertices. There are only two public methods available, solve() and printSolution(). The former uses a Welsh-Powell algorithm in the graph class to find a coloring for the graph and the latter allows the user to print out the solution to the console.


The main difference between a sudoku graph and the graphs in this paper to this point is that a sudoku graph is already partially colored. This adds some complexity to the vertex coloring problem since now there are some restrictions on which colors one can place on certain vertices. This means in its current state, the Welsh-Powell algorithm used to this point will not work as well, and proper colorings will typically involve more than the 9 colors required for a solution. This is why the solve() method in the SudokuGrid class calls on the Graph class' partiallySolvedWelshPowell() method instead of the typical welshPowell() method used in the other applications. The code for this tweaked algorithm is the following.


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
// Uses the Welsh-Powell algorithm to solve a partially colored graph by finding the empty vertices with the
    // highest degree of colored edges and coloring it the first available color. Repeat for the vertices with
    // descending degrees.
    public Integer[] partiallySolvedWelshPowell(Integer[] knownColorings){
        vertexColors = new Integer[vertexCount];
        isColored = new boolean[vertexCount];
        for (int i = 0; i < knownColorings.length; i++) {
            if (knownColorings[i] != null){
                isColored[i] = true;
                vertexColors[i] = (knownColorings[i] - 1);
            }
        }
        for (int i = 0; i < vertexDegrees.length; i++) {
            Integer currVertex = highestColorDegree();
            if (!isColored[currVertex]){
                int tmpColor = findFirstNonAdjacentColor(currVertex,0);
                vertexColors[currVertex] = tmpColor;
                isColored[currVertex] = true;
            }
        }
        for (int i = 0; i < vertexColors.length; i++) {
            knownColorings[i] = vertexColors[i] + 1;
        }
        return knownColorings;
    }
\end{lstlisting}


 In this method, the algorithm is tweaked slightly; instead of finding the vertex with the highest degree, coloring and iterating, we instead sort the non-colored vertices by their degree of uniquely colored adjacent vertices and color those and iterate. It starts by placing the known color values that were passed into the method into the vertexColor array (but first decrementing the value since the arrays are index-0 but sudoku numbers are index-1) and marks the vertices as colored. Next it finds the next non-colored vertex with the highest color degree, meaning it has the most unique edges with vertices of other colors. then we check that it's not colored and if it isn't, we find the first nonadjacent color. Since this vertex has a high degree of adjacent colors, it's likely that there aren't many options for its color. We then color the vertex this nonadjacent color and mark it as colored. We repeat these steps until the graph has a proper coloring. Lastly, we increment all the colors back up to the original values since the sudoku numbers are index-1 based. If the algorithm succeeded in finding a solution, it will have only used 9 colors in its coloring. It is not always successful though because the Welsh-Powell algorithm is a greedy algorithm and not a backtracking algorithm. This algorithm can solve most easy sudoku puzzles which is pretty impressive.
 
To see this tweaked Welsh-Powell algorithm in action, let us use the following driver code.


\begin{lstlisting}[language = Java , frame = trBL , firstnumber = last , escapeinside={(*@}{@*)}]
public class Main {
    public static void main(String args[]){
        Integer[] values = {
                null,null,null,2,6,null,7,null,1,
                6,8,null,null,7,null,null,9,null,
                1,9,null,null,null,4,5,null,null,
                8,2,null,1,null,null,null,4,null,
                null,null,4,6,null,2,9,null,null,
                null,5,null,null,null,3,null,2,8,
                null,null,9,3,null,null,null,7,4,
                null,4,null,null,5,null,null,3,6,
                7,null,3,null,1,8,null,null,null
                };
        SudokuGrid sud = new SudokuGrid(values);
        sud.solve();
        sud.printSolution();
    }
}
\end{lstlisting}


This Integer array represents the unsolved grid where the null values are empty cells. Running this code produces the following output.


\begin{center}
\includegraphics[scale=1]{sudokuOutput.png}
\end{center}


As we can observe by inspection, the output solved sudoku grid is a proper coloring. There are no repeated values in any row, column, or respective 3x3 square and the algorithm managed to only use the 9 colors.


\begin{figure}[h!]%
\begin{center}
	\subfloat[Unsolved grid prior to Welsh-Powell coloring]{{\includegraphics[scale=1]{sudokuUnsolved.png}}}%
	\qquad
\subfloat[Solved grid after Welsh-Powell Coloring]{{\includegraphics[scale=1]{sudokuSolved.png}}}%
\end{center}
\end{figure}


As has been made evident in this paper, the Welsh-Powell graph coloring algorithm is a very flexible and powerful tool that can be applied to solve many problems. Though not the most powerful, quickest, or most sophisticated graph coloring algorithm, it is relatively easy to follow and implement and works fairly well.
\end{document}
